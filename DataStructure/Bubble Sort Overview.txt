Bubble Sort: Overview

Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted.
How It Works:

    Start from the first element of the array.
    Compare each pair of adjacent elements.
    Swap them if the first is greater than the second.
    Repeat this process for all elements until no swaps are needed (indicating the array is sorted)Pros of Bubble Sort:

    Easy to Understand and Implement: It's a simple algorithm, good for learning how sorting works.
    Stable: It keeps the order of equal elements intact, meaning elements that are the same stay in their original order.
    Best Case Performance: If the list is already sorted, it finishes quickly, only needing one pass.

    Cons of Bubble Sort:

    Inefficient for Large Lists: It can be very slow with large datasets, as it takes a lot of comparisons and swaps.
    Too Many Comparisons and Swaps: Even when the list isn't sorted, it performs many unnecessary operations.
    Time Complexity

    Worst Case: O(n2)
        Occurs when the array is sorted in reverse order.
    Best Case: O(n)
        Occurs when the array is already sorted, requiring only one pass.
    Average Case: O(n2)
        Occurs when elements are randomly ordered.
   space complexity remains constant: O(1).     
   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   Selection Sort: Efficient Summary

Selection Sort is a simple sorting algorithm that repeatedly selects the smallest (or largest) element from the unsorted portion of the list and places it in its correct position.
How It Works:

    Find the smallest element in the unsorted part of the list.
    Swap it with the first unsorted element.
    Repeat this process until the list is sorted.

Pros:

    Simple to implement.
    In-place sorting: No extra memory needed (space complexity is O(1)O(1)).
    Fewer swaps than bubble sort.

Cons:

    Inefficient for large lists due to O(n2)O(n2) time complexity.
    Doesn't adapt to already sorted data.

Time Complexity:

    Best, Worst, Average Case: O(n2)O(n2).

Space Complexity:

    Space Complexity: O(1)O(1) (constant space).
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Merge Sort: Summary
Pros:

    Efficient for large datasets: Consistent O(n log n) performance.
    Stable: Preserves the relative order of equal elements.
    Divides work: Suitable for parallel processing.
    Good worst-case performance: Always O(n log n) in all cases.

Cons:

    Space complexity: Requires extra space for temporary arrays (O(n)).
    Not in-place: Needs additional memory for sorting.
    Slower for small arrays: Overhead may make it slower than other algorithms like quicksort or insertion sort for small datasets.

Time Complexity:

    Best Case: O(n log n)
    Average Case: O(n log n)
    Worst Case: O(n log n)

Space Complexity:

    O(n): Requires additional space for temporary arrays.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Insertion Sort is a simple comparison-based sorting algorithm that builds the sorted array (or list) one element at a time. It works similarly to how you might sort playing            
    cards       in your hands:

    Start with the first card as sorted.
    Pick the next card and insert it into the correct position in the sorted part.
    Repeat this for all cards until the entire hand is sorted.
    Advantages of Insertion Sort:

    Simple to Implement:
        Easy to understand and code, making it a good starting point for learning sorting algorithms.

    Efficient for Small or Nearly Sorted Data:
        Performs very well on small datasets or when the data is already mostly sorted.

    Stable Sorting Algorithm:
        Maintains the relative order of equal elements (e.g., if two 5s are in the input, their order remains the same in the sorted output).

    In-Place Sorting:
        Requires no additional memory, as sorting is done within the original array or list (Space Complexity: O(1)).

    Adaptive:
        It can stop early if the input is already sorted, giving it O(n) time complexity in the best case.

Disadvantages of Insertion Sort:

    Slow for Large Datasets:
        Time complexity is O(n²) in the worst and average cases, making it inefficient for large datasets.

    Not Suitable for Random Access:
        For linked lists, it may require traversal to find the insertion point, which increases overhead.

    Comparisons Increase with Size:
        As the input size grows, the number of comparisons and shifts increases, slowing down the algorithm.

    Not Parallelizable:
        Insertion sort processes elements one at a time, making it unsuitable for parallel execution.
    Why Insertion Sort is Good for Linked Lists (Simplified):

    No Shifting of Elements:
        In linked lists, sorting doesn’t require shifting elements like arrays. You simply update pointers to rearrange nodes.

    Efficient Rearrangement:
        Once the correct position is found, moving a node is fast in a linked list because only the next pointers are updated.

    Dynamic Size:
        Linked lists can grow or shrink dynamically, so no resizing is needed during sorting.

    Memory Optimization:
        Sorting in a linked list involves fewer memory operations compared to arrays, as no elements need to be physically moved.

    Stable Sorting:
        Insertion sort ensures the relative order of equal elements remains the same, and this is naturally preserved in linked lists.
